import json
import logging
import os
import requests
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler, ContextTypes

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
if not TELEGRAM_BOT_TOKEN:
    raise ValueError("No TELEGRAM_BOT_TOKEN set. Please set it as an environment variable.")

user_data_store = {}

def get_role_label(role_key):
    roles = {
        'supplier': 'ÿ™ÿßŸÖ€åŸÜ ⁄©ŸÜŸÜÿØŸá',
        'exporter': 'ÿµÿßÿØÿ± ⁄©ŸÜŸÜÿØŸá / ÿ™ÿßÿ¨ÿ±',
        'seller': 'ŸÅÿ±Ÿàÿ¥ŸÜÿØŸá',
        'buyer': 'ÿÆÿ±€åÿØÿßÿ±',
        'customs': 'ÿÆÿØŸÖÿßÿ™ ⁄ØŸÖÿ±⁄©€å',
        'logistics': 'ÿ≠ŸÖŸÑ Ÿà ŸÜŸÇŸÑ',
    }
    return roles.get(role_key, role_key)

def format_contact(contact):
    lines = [
        f"üë§ *ŸÜÿßŸÖ:* {contact.get('companyName', 'ŸÜÿßŸÖÿ¥ÿÆÿµ')}",
        f"üìû *ÿ™ŸÑŸÅŸÜ:* `{contact.get('phone', 'ŸÜÿßŸÖÿ¥ÿÆÿµ')}`",
        f" ‡§≠‡•Ç‡§Æ‡§ø‡§ï‡§æ *ŸÜŸÇÿ¥:* {get_role_label(contact.get('role'))}",
        f"üìù *ÿ™ÿÆÿµÿµ:* {contact.get('description', 'ŸÜÿßŸÖÿ¥ÿÆÿµ')}",
        f"üîë *⁄©ŸÑŸÖÿßÿ™ ⁄©ŸÑ€åÿØ€å:* {contact.get('keywords', 'ŸÜÿßŸÖÿ¥ÿÆÿµ')}",
    ]
    if contact.get('website'):
        lines.append(f"üåê *Ÿàÿ®‚Äåÿ≥ÿß€åÿ™:* {contact['website']}")
    if contact.get('address'):
        lines.append(f"üìç *ÿ¢ÿØÿ±ÿ≥:* {contact['address']}")
    return "\n".join(lines) + "\n--------------------"

async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE, message_text: str):
    keyboard = [
        [InlineKeyboardButton("ŸáŸÖŸá", callback_data='cat_all'), InlineKeyboardButton("ÿ™ÿßŸÖ€åŸÜ ⁄©ŸÜŸÜÿØ⁄ØÿßŸÜ", callback_data='cat_supplier')],
        [InlineKeyboardButton("ÿµÿßÿØÿ± ⁄©ŸÜŸÜÿØ⁄ØÿßŸÜ", callback_data='cat_exporter'), InlineKeyboardButton("ÿÆÿ±€åÿØÿßÿ±ÿßŸÜ", callback_data='cat_buyer')],
        [InlineKeyboardButton("ÿÆÿØŸÖÿßÿ™ ⁄ØŸÖÿ±⁄©€å", callback_data='cat_customs'), InlineKeyboardButton("ÿ≠ŸÖŸÑ Ÿà ŸÜŸÇŸÑ", callback_data='cat_logistics')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    if update.callback_query:
        await update.callback_query.edit_message_text(text=message_text, reply_markup=reply_markup)
    else:
        await update.message.reply_text(message_text, reply_markup=reply_markup)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_name = update.effective_user.first_name
    welcome_text = (f"ÿ≥ŸÑÿßŸÖ {user_name}!\n\nÿ®Ÿá ÿ±ÿ®ÿßÿ™ ŸÖÿØ€åÿ±€åÿ™ ÿ¥ÿ®⁄©Ÿá ÿ™ÿ¨ÿßÿ±€å ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ.\n\nŸÑÿ∑ŸÅÿßŸã ŸÅÿß€åŸÑ JSON ŸÖÿÆÿßÿ∑ÿ®€åŸÜ ÿÆŸàÿØ €åÿß ŸÑ€åŸÜ⁄© ŸÖÿ≥ÿ™ŸÇ€åŸÖ Gist ÿ¢ŸÜ ÿ±ÿß ÿ®ÿ±ÿß€å ŸÖŸÜ ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ.")
    await update.message.reply_text(welcome_text)

async def handle_file(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    file = await update.message.document.get_file()
    file_content = await file.download_as_bytearray()
    try:
        contacts = json.loads(file_content.decode('utf-8'))
        user_data_store[user_id] = contacts
        logger.info(f"Successfully loaded {len(contacts)} contacts for user {user_id} from file.")
        await show_main_menu(update, context, f"‚úÖ ŸÅÿß€åŸÑ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ¥ÿØ. {len(contacts)} ŸÖÿÆÿßÿ∑ÿ® ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ¥ÿØ.\n\nŸÑÿ∑ŸÅÿßŸã ÿØÿ≥ÿ™Ÿá‚Äåÿ®ŸÜÿØ€å ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:")
    except Exception as e:
        logger.error(f"Error processing file for user {user_id}: {e}")
        await update.message.reply_text(f"‚ùå ÿÆÿ∑ÿß€å ÿ∫€åÿ±ŸÖŸÜÿ™ÿ∏ÿ±Ÿá‚Äåÿß€å ÿ±ÿÆ ÿØÿßÿØ: {e}")

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    text = update.message.text
    if "gist.github.com" in text:
        await update.message.reply_text("‚è≥ ÿØÿ± ÿ≠ÿßŸÑ ÿØÿ±€åÿßŸÅÿ™ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿßÿ≤ ŸÑ€åŸÜ⁄©...")
        try:
            if "/raw/" not in text:
                if '#' in text:
                    text = text.split('#')[0]
                text = text + '/raw'
            response = requests.get(text)
            response.raise_for_status()
            contacts = response.json()
            user_data_store[user_id] = contacts
            logger.info(f"Successfully loaded {len(contacts)} contacts for user {user_id} from link.")
            await show_main_menu(update, context, f"‚úÖ ŸÑ€åŸÜ⁄© ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ¥ÿØ. {len(contacts)} ŸÖÿÆÿßÿ∑ÿ® ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ¥ÿØ.\n\nŸÑÿ∑ŸÅÿßŸã ÿØÿ≥ÿ™Ÿá‚Äåÿ®ŸÜÿØ€å ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:")
        except Exception as e:
            logger.error(f"Error processing link for user {user_id}: {e}")
            await update.message.reply_text(f"‚ùå ÿÆÿ∑ÿß€å ÿ∫€åÿ±ŸÖŸÜÿ™ÿ∏ÿ±Ÿá‚Äåÿß€å ÿ±ÿÆ ÿØÿßÿØ: {e}")
    else:
        await update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã €å⁄© ŸÅÿß€åŸÑ JSON €åÿß ŸÑ€åŸÜ⁄© ŸÖÿπÿ™ÿ®ÿ± Gist GitHub ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ.")

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    user_id = query.effective_user.id
    data = user_data_store.get(user_id)
    if not data:
        await query.edit_message_text(text="‚ùå ÿßÿ∑ŸÑÿßÿπÿßÿ™€å ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ. ŸÑÿ∑ŸÅÿßŸã ÿßÿ®ÿ™ÿØÿß €å⁄© ŸÅÿß€åŸÑ ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ.")
        return

    parts = query.data.split('_')
    command = parts[0]

    if command == 'cat':
        category = '_'.join(parts[1:])
        page = 0
    elif command == 'page':
        category = parts[1]
        page = int(parts[2])
    elif command == 'back':
        await show_main_menu(update, context, "ŸÑÿ∑ŸÅÿßŸã ÿØÿ≥ÿ™Ÿá‚Äåÿ®ŸÜÿØ€å ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:")
        return
    else: return

    filtered_contacts = data if category == 'all' else [c for c in data if c.get('role') == category]
    if not filtered_contacts:
        await query.edit_message_text(text=f"Ÿá€å⁄Ü ŸÖÿÆÿßÿ∑ÿ®€å ÿØÿ± ÿØÿ≥ÿ™Ÿá‚Äåÿ®ŸÜÿØ€å '{get_role_label(category)}' €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
        return

    items_per_page = 5
    start_index = page * items_per_page
    end_index = start_index + items_per_page
    paginated_contacts = filtered_contacts[start_index:end_index]

    message_text = f"üìÇ *ÿØÿ≥ÿ™Ÿá ÿ®ŸÜÿØ€å:* {get_role_label(category)}\n"
    message_text += f"üë• *ÿ™ÿπÿØÿßÿØ ⁄©ŸÑ:* {len(filtered_contacts)}\n\n"
    message_text += "\n".join([format_contact(c) for c in paginated_contacts])

    keyboard_nav = []
    row = []
    if page > 0: row.append(InlineKeyboardButton("‚¨ÖÔ∏è ŸÇÿ®ŸÑ€å", callback_data=f"page_{category}_{page - 1}"))
    if end_index < len(filtered_contacts): row.append(InlineKeyboardButton("ÿ®ÿπÿØ€å ‚û°Ô∏è", callback_data=f"page_{category}_{page + 1}"))
    if row: keyboard_nav.append(row)
    keyboard_nav.append([InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà ÿßÿµŸÑ€å", callback_data="back_to_menu")])

    await query.edit_message_text(text=message_text, reply_markup=InlineKeyboardMarkup(keyboard_nav), parse_mode='Markdown')

def main() -> None:
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.Document.MimeType("application/json"), handle_file))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    application.add_handler(CallbackQueryHandler(button_callback))
    application.run_polling()

if __name__ == '__main__':
    main()
